from flask import Flask, render_template, request, redirect, url_for, session
import fdb
from datetime import datetime

# --- CONFIGURACIÓN ---
app = Flask(__name__, template_folder="templates")
# Necesario para usar 'session'
app.secret_key = 'secret-key' 

def get_db():
    # Nota: La configuración de la base de datos es local y debe ser accesible.
    return fdb.connect(
        host='localhost',
        database=r'C:\Users\garit\Documents\CODENOVA.FDB',
        user='SYSDBA',
        password='masterkey'
    )

def init_db():
    """Inicializa la base de datos, crea tablas si no existen y garantiza un usuario ADMIN."""
    admin_username = "admin"
    admin_password = "1234"
    admin_rol = 'ADMIN'
    
    try:
        with get_db() as db:
            cur = db.cursor()
            
            # --- TABLA USUARIOS (Creación o Ignorar si existe) ---
            try:
                cur.execute("""
                CREATE TABLE usuarios (
                    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    username VARCHAR(50) UNIQUE NOT NULL, 
                    password VARCHAR(100) NOT NULL,
                    fecha_creacion DATE,
                    rol VARCHAR(10) DEFAULT 'ALUMNO' 
                )
                """)
                print("Tabla 'usuarios' creada.")
            except fdb.exceptions.ProgrammingError as e:
                # El error 335544641 (Dynamic SQL Error, Table already exists) es normal
                if "already exists" not in str(e):
                    raise 
            except Exception as e:
                print(f"Error al crear la tabla usuarios: {e}")

            # --- TABLA ALUMNOS (Creación o Ignorar si existe) ---
            try:
                cur.execute("""
                CREATE TABLE alumnos (
                    matricula VARCHAR(20) PRIMARY KEY,
                    nombre VARCHAR(100),
                    carrera VARCHAR(100),
                    semestre INTEGER,
                    deuda NUMERIC(10,2)
                )
                """)
                print("Tabla 'alumnos' creada.")
            except fdb.exceptions.ProgrammingError as e:
                if "already exists" not in str(e):
                    raise 
            except Exception as e:
                print(f"Error al crear la tabla alumnos: {e}")

            # --- VERIFICACIÓN Y CREACIÓN/ACTUALIZACIÓN DE USUARIO ADMINISTRADOR ---
            cur.execute("SELECT id FROM usuarios WHERE username=?", (admin_username,))
            user_exists = cur.fetchone()
            
            if user_exists is None:
                # El usuario no existe: lo insertamos
                print(f"Creando usuario {admin_rol} por defecto...")
                try:
                    cur.execute(
                        "INSERT INTO usuarios (username, password, fecha_creacion, rol) VALUES (?, ?, ?, ?)",
                        (admin_username, admin_password, datetime.today().date(), admin_rol)
                    )
                    print(f"Usuario {admin_rol} ('{admin_username}' / '{admin_password}') creado exitosamente.")
                except Exception as e:
                    print(f"Error al insertar usuario {admin_rol}: {e}")
            else:
                # El usuario existe: nos aseguramos de que tenga el rol ADMIN y la contraseña por defecto.
                print(f"Usuario '{admin_username}' existe. Asegurando que su rol sea '{admin_rol}'.")
                try:
                    cur.execute(
                        "UPDATE usuarios SET rol = ?, password = ? WHERE username = ?",
                        (admin_rol, admin_password, admin_username)
                    )
                    print(f"Rol y contraseña de '{admin_username}' actualizados a '{admin_rol}'.")
                except Exception as e:
                    print(f"Error al actualizar el rol de {admin_username}: {e}")

            db.commit()
    except Exception as e:
        print(f"Error en la inicialización de la base de datos: {e}. Asegúrese de que la base de datos Firebird esté activa y la ruta sea correcta.")
        
# -------------------- RUTAS DE ACCESO PRINCIPAL --------------------

@app.route("/")
def home():
    """Ruta principal (/). Siempre muestra la interfaz de bienvenida homeshell.html."""
    return render_template("homeshell.html") 


@app.route("/manifest")
def manifest():
    return render_template("templates/manifest.json") 

@app.route("/login", methods=["GET", "POST"])
def login():
    """
    MANEJA EL ENDPOINT 'login' (GET y POST).
    POST: Valida credenciales y redirige al dashboard correcto.
    """
    if request.method == "POST":
        # --- Lógica de Validación (POST) ---
        username = request.form.get("username")
        password = request.form.get("password")
        
        if not username or not password:
            return render_template("login.html", error="Faltan datos") 

        with get_db() as db:
            cur = db.cursor()
            
            # Verificación en la DB
            cur.execute("SELECT id, rol FROM usuarios WHERE username=? AND password=?", (username, password))
            row = cur.fetchone()
            
            if row:
                id_usuario, rol = row[0], row[1]
                
                # ESTANDARIZACIÓN CRÍTICA DEL ROL
                rol_str = 'ALUMNO' 
                if rol is not None:
                    # Aplicamos strip() y upper() para máxima robustez
                    rol_str = str(rol).strip().upper() 

                # Guardamos datos esenciales en la sesión
                session['user_id'] = id_usuario
                session['rol'] = rol_str # Valor potencialmente sucio de la DB
                session['username'] = username 
                
                # Redirección basada en rol O nombre de usuario
                if rol_str == "ADMIN" or username.lower() == "admin": 
                    
                    # FIX CRÍTICO: Asegurar que el rol en la sesión sea 'ADMIN' para el usuario 'admin'
                    if username.lower() == "admin":
                        session['rol'] = 'ADMIN' 

                    # REDIRECCIÓN EXPLICITA PARA EL ADMINISTRADOR
                    return redirect(url_for("admin_dashboard")) # REDIRECCIÓN A LA NUEVA RUTA
                else:
                    # Esto cubre 'ALUMNO' o cualquier otro rol no 'ADMIN'.
                    return redirect(url_for("ver_deuda_alumno")) 
            else:
                return render_template("login.html", error="Usuario o contraseña incorrectos")

    # --- Lógica de Visualización (GET) ---
    msg = request.args.get('msg')
    error = request.args.get('error')
    
    return render_template("login.html", msg=msg, error=error)

@app.route("/registro", methods=["POST"])
def registro():
    """El usuario se auto-registra (siempre como ALUMNO)."""
    username = request.form.get("username") 
    password = request.form.get("password")
    
    if not username or not password:
        return redirect(url_for("login", error="Faltan datos en el registro."))

    with get_db() as db:
        cur = db.cursor()
        try:
            cur.execute(
                # Aseguramos que los usuarios creados aquí sean ALUMNO por defecto
                "INSERT INTO usuarios (username, password, fecha_creacion, rol) VALUES (?, ?, ?, ?)",
                (username, password, datetime.today().date(), 'ALUMNO')
            )
            db.commit()
            return redirect(url_for("admin_dashboard"))
        except Exception as e:
            # Captura errores como 'La matrícula ya está registrada' (violación de UNIQUE constraint)
            return redirect(url_for("login", error=f"Error: La matrícula ya está registrada o error de DB: {str(e)}"))

@app.route('/logout')
def logout():
    """Cierra la sesión del usuario y lo redirige al home (/homeshell.html)."""
    session.clear()
    return redirect(url_for("home"))

# -------------------- RUTA ALUMNO: VER DEUDA --------------------

@app.route("/deuda_alumno")
def ver_deuda_alumno():
    """Muestra la deuda del alumno logueado."""
    # Seguridad básica
    if 'user_id' not in session:
        return redirect(url_for("login")) 
        
    # Comprobación de seguridad CRÍTICA: si un ADMIN llega aquí, lo redirigimos a su dashboard.
    if session.get('rol') == 'ADMIN':
        return redirect(url_for("admin_dashboard"))

    # Si no es ADMIN, comprobamos que sea ALUMNO antes de continuar
    if session.get('rol') != 'ALUMNO':
        return redirect(url_for("login")) 
        
    matricula = session.get('username')
    
    with get_db() as db:
        cur = db.cursor()
        
        # Consulta la tabla alumnos usando la MATRÍCULA
        cur.execute("""
            SELECT 
                nombre, 
                deuda 
            FROM 
                alumnos 
            WHERE 
                matricula = ?
        """, (matricula,))
        
        deuda_registro = cur.fetchone()
        
        # Se asume que el template para el alumno se llama "tablero_alumno.html"
        if deuda_registro:
            nombre_alumno, deuda_monto = deuda_registro[0], deuda_registro[1]
            return render_template("tablero_alumno.html", 
                                   nombre=nombre_alumno, 
                                   deuda=deuda_monto,
                                   matricula=matricula,
                                   now=datetime.now) 
        else:
            return render_template("tablero_alumno.html", 
                                   nombre=matricula, 
                                   deuda=0.00,
                                   matricula=matricula,
                                   msg="Tu ficha de deuda está pendiente de ser asignada por el administrador.",
                                   now=datetime.now) 

# -------------------- RUTAS ADMIN (PANEL UNIFICADO) --------------------

@app.route("/admin_dashboard", methods=["GET", "POST"])
def admin_dashboard():
    """
    Ruta unificada para el ADMIN. 
    GET: Muestra el dashboard con el formulario de asignación (incluyendo el SELECT) y la tabla de registros.
    POST: Maneja la edición y eliminación de registros de la tabla.
    """
    
    # Seguridad básica (verificación de rol)
    if session.get('rol') != 'ADMIN':
        return redirect(url_for("login", error="Acceso denegado."))

    msg_success = request.args.get('msg_success') 
    error_msg = request.args.get('error')
    
    with get_db() as db:
        cur = db.cursor()

        # --- LÓGICA POST: EDICIÓN O ELIMINACIÓN DE REGISTROS (DESDE LA TABLA) ---
        if request.method == "POST":
            accion = request.form.get("accion")
            matricula = request.form.get("matricula")
            
            try:
                if accion == "eliminar":
                    cur.execute("DELETE FROM alumnos WHERE matricula=?", (matricula,))
                    msg_success = f"Ficha de deuda para Matrícula {matricula} eliminada."
                elif accion == "editar":
                    nombre = request.form.get("nombre")
                    carrera = request.form.get("carrera")
                    try:
                        semestre = int(request.form.get("semestre"))
                        deuda = float(request.form.get("deuda"))
                    except ValueError:
                        error_msg = "Datos de Semestre o Deuda inválidos."
                        
                    if not error_msg:
                         cur.execute("""
                            UPDATE alumnos 
                            SET nombre=?, carrera=?, semestre=?, deuda=?
                            WHERE matricula=?
                        """, (nombre, carrera, semestre, deuda, matricula))
                         msg_success = f"Ficha de deuda para {nombre} actualizada correctamente."
                
                db.commit()
            except Exception as e:
                error_msg = f"Error en la operación de DB: {str(e)}"
        
        # --- LÓGICA GET: OBTENCIÓN DE DATOS (PARA VISUALIZACIÓN) ---
        
        # 1. Obtener registros de alumnos (para la tabla)
        cur.execute("SELECT matricula, nombre, carrera, semestre, deuda FROM alumnos")
        registros = cur.fetchall()
        
        # 2. Obtener usuarios registrados (matrículas) para el SELECT, EXCLUYENDO al administrador.
        # Esto se basa en su aclaración de que todos los demás usuarios son alumnos.
        # Usamos el username de la sesión actual (admin) para excluirse.
        admin_user = session.get('username', 'admin') 
        cur.execute("SELECT username FROM usuarios WHERE username != ? ORDER BY username", (admin_user,))
        usuarios_registrados = [row[0] for row in cur.fetchall()]
        
        # Imprime en consola para depuración
        print(f"DEBUG: Usuarios (Matrículas) encontrados para el SELECT: {usuarios_registrados}")
        
    return render_template(
        "admin_registros.html", 
        registros=registros, 
        usuarios=usuarios_registrados, # Se pasa la lista para el SELECT
        msg_success=msg_success,
        error=error_msg
    )


@app.route('/admin/crear_ficha', methods=['POST'])
def admin_crear_ficha():
    """Maneja la acción POST del formulario de asignación de deuda."""
    
    if session.get('rol') != 'ADMIN':
        return redirect(url_for("login", error="Acceso denegado."))

    error_msg = None
    
    matricula = request.form.get('matricula')
    nombre = request.form.get('nombre')
    carrera = request.form.get('carrera')
    semestre = request.form.get('semestre')
    deuda = request.form.get('deuda')
    
    if not all([matricula, nombre, carrera, semestre, deuda]):
        error_msg = "Todos los campos son obligatorios."
    else:
        try:
            semestre_int = int(semestre)
            deuda_float = float(deuda)
        except ValueError:
            error_msg = "El semestre debe ser un número entero y la deuda un número válido."
        
        if not error_msg:
            with get_db() as db:
                cur = db.cursor()
                
                # A. Verificamos que exista un usuario de login con esa matrícula.
                cur.execute("SELECT id FROM usuarios WHERE username = ?", (matricula,))
                if not cur.fetchone():
                    error_msg = f"Error: No existe un usuario registrado con la matrícula/username '{matricula}'."
                else:
                    try:
                        # B. Insertamos la ficha de deuda.
                        cur.execute(
                            "INSERT INTO alumnos (matricula, nombre, carrera, semestre, deuda) VALUES (?, ?, ?, ?, ?)",
                            (matricula, nombre, carrera, semestre_int, deuda_float)
                        )
                        db.commit()
                        return redirect(url_for('admin_dashboard', msg_success=f"Ficha de deuda para {nombre} ({matricula}) registrada."))
                    except Exception as e:
                        error_msg = f"Error: La matrícula ya tiene una ficha de deuda o error DB: {str(e)}"
    
    # Si hay un error, redirige al dashboard con el mensaje de error
    return redirect(url_for('admin_dashboard', error=error_msg))

# -------------------- MAIN --------------------
if __name__ == "__main__":
    init_db()
    app.run(debug=True)
